# 数组

## 35 搜索插入位置

题目表述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**提示:**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为 **无重复元素** 的 **升序** 排列数组
- `-104 <= target <= 104`

思路：

- 有序数组+无重复值 -> 二分查找
- 返回值是不大于目标值的最小索引
- 当目标值存在目标值中返回mid
- 当目标值在[low, high)之间，返回low
- 当目标值不在数组内，返回low，即头或尾

代码：

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int t) {
        int low = 0;
        int high = nums.size();
        while (low < high) {//退出循环时，必有target >= num[low]
            // 当目标值存在目标值中返回mid
            int mid = (low + high) / 2;//找中点索引
            if (nums[mid] > t) {
                high = mid;
            }
            else if (nums[mid] < t) {
                low = mid+1;
            }
            else {
                return mid;
            }
        }
        // 当目标值在[low, high)之间，返回low
		// 当目标值不在数组内，此时low必然为头或尾，因此返回low
        return low;

        // int  len = nums.size();
        // for(int i = 0; i < len; i++)
        //     if(nums[i]==t)
        //         return i;
        // for(int j = 0; j < len; j++)
        //     if(t < nums[j])
        //         return j;
        // return len;

    }
};
```

 

## 34 在排序数组中查找元素的第一个和最后一个位置

题目：

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

提示：

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- `nums` 是一个非递减数组
- `-109 <= target <= 109`

思路：

首先分析目标值可能存在的情况，分为以下三种

- 情况一: 目标值不在数组范围内，即 t<a.begin() or t > a.end() return {-1, -1}

- 情况二: 目标值在数组范围内，且存在该值 即存在index 使得 a[index]==t return {左边界+1，右边界-1}

- 情况三: 目标值在数组范围内，但并不存在该值, 即 a.begin() <= t <= a.end() return {-1, -1}

  

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& a, int t) {
        int leftBorder = getLeftBorder1( a, t);
        int rightBorder = getRightBorder1( a, t);
        //此时目标值有三种可能
        //情况一: 目标值不在数组范围内，即 t<a.begin() or t > a.end() return {-1, -1}
        //情况二: 目标值在数组范围内，且存在该值 即存在index 使得 a[index]==t return {左边界，有边界}
        //情况三: 目标值在数组范围内，但并不存在该值, 即 a.begin() <= t <= a.end() return {-1, -1}
        
        //针对情况一：左边界或者右边界在数组范围外
        if ( leftBorder == -2 || rightBorder == -2) return {-1, -1};
        //针对情况二：左边界<右边界,且其差一定大于1 或者说 大于等于2
        if ( (rightBorder - leftBorder) > 1 )  return {leftBorder + 1, rightBorder - 1};
        //针对情况三，左边界和右边界已修改，且左右边界之差为1
        else return {-1, -1};
    }       
    
private:
//二分法查找左边界和右边界
//第一种：左闭右闭二分查找
    int getLeftBorder1(vector<int>& a, int t) {
        //首先确定左右起始点, 左闭右闭组合
        int low = 0;
        int high = a.size() - 1;
        int leftBorder = -2;//先预设左边界为-2
        while (low <= high) {
            int mid = (low + high) / 2;
            if (a[mid] >= t) {//左边界一定存在于a[mid]==target的左边
                high = mid - 1;
                leftBorder = high;
            }
            else {
                low = mid + 1;//当a[low]等于target的时候，,再往下一步就是high<left，循环就break了
            }
        }
        return leftBorder;
    }
    
    int getRightBorder1(vector<int>& a, int t) {
        int low = 0;
        int high = a.size() - 1;
        int rightBorder = -2;//预设右边界
        while (low <= high ) {
            int mid = ( low + high ) / 2;
            //右边界一定存在于a[mid]==target 的右边
            if (a[mid] > t) {
                high = mid - 1;
            }
            else {
                low = mid + 1;
                rightBorder = low;
            }
        }
        return rightBorder;
    }

};
```



## 69 x的算术平方根

题目：

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

提示：

- `0 <= x <= 231 - 1`

思路：

三种方法：暴力解法、二分查找、牛顿迭代法

暴力解法和二分查找本质上一样，都是找到一个数=={${a|a^2\leq x  \textless (a+1)^2 }$}==

该题最重要的思路就是想到上面公式

代码：

### 1.暴力解法

### 2.二分查找

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int low = 0;
        int high = x;
        int ans = -1;
        while ( low <= high ) {
            int mid = (low + high) / 2;//注意mid不能用int 会溢出
            if ((long long)mid*mid > x) {
                high = mid - 1;
            }
            else {
                ans = (int)mid;
                low = mid + 1;
            }
        }
        return ans;
    }
};	
```

### 3.牛顿迭代法

代码：

```cpp
class Solution {
public:
    int mySqrt(int x) {
        //牛顿法
        // ans = (ans + x/ans) / 2
        // 当ans 
        long long  ans = x;
        while ( ans*ans > x ) {
            ans = ( ans + x/ans ) / 2; 
        } 
        return (int)ans;
    }
};
```

## 367 有效的完全平方根

题目：

给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如  sqrt 。

提示：

- `1 <= num <= ${2^{31} -1}$`

思路1：暴力解法，采用双层循环，将查找到的元素后面的元素依次前移，时间复杂度为${O^2}$

```cpp
int removeElement(vector<int>& nums, int val) {
        int len = nums.size();
        for (int i = 0; i < len; i++) {
            if (nums[i] == val) {
                for (int j = i; j < len-1; j++) {
                    nums[j] = nums[j+1];//i后面所有元素前移
                }
                i--;
                len--;
            }
        }
        return len;
```

思路2：双指针，构造快慢指针，快指针用来遍历数组，慢指针用来更新数组

- 原则：只有当nums[fast] ！= val；

```cpp
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;//慢指针
        for (int fast = 0; fast < nums.size(); fast++) {
            if (nums[fast] != val) {//当快指针指向的值不等于目标值
                nums[slow] = nums[fast];//则将快指针的值赋给慢指针
                slow++;//慢指针+1
            }//快指针也+1

        }
        return slow;
    }
};
```

## 26 删除有序数组中的重复项

**题目：**
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **升序** 排列

**思路:**

- 构造**快慢指针**
  - 快指针遍历数组
  - 慢指针指向非重复元素存放位置
  - 最终停止迭代时，**慢指针指向最后一个非重复元素的索引，因此返回的慢指针长度+1**

**代码：**

```cpp
int removeDuplicates(vector<int>& nums) {
        //快慢指针
        //慢指针表示保存非重复元素
        //快指针遍历整个数组
        int slow = 0;
        for ( int fast = 0; fast < nums.size(); fast++) {
            if ( nums[fast] != nums[slow] ) {
                slow++;
                nums[slow] = nums[fast];
            }//此时慢指针指向最后一个非重复元素的索引，即size-1
        }
        return slow + 1;
```







```cpp
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        //快慢指针
        //慢指针输出a，b的退格字符串
        changeString(s);
        changeString(t);

        return s==t;
    }
protected:
    void changeString(string & s) {
        int slow_s = 0;
        for ( int fast = 0; fast < s.size(); fast++ ) {

            if ( s[fast] != '#' ) {
                s[slow_s] = s[fast];
                slow_s++;
            }
            else if (slow_s != 0){
                slow_s--;
            }
        }
        s.resize(slow_s);
    }
};
```

## 977 有序数组的平方

**题目：**

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**提示：**

- `1 <= nums.length <= 104` 
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

**思路：**

方法1：暴力排序

- 采用快速排序法直接对平方后的数组进行排序
- 时间复杂度 = O(n + nlogn)

```cpp
vector<int> sortedSquares(vector<int>& nums) {
        //将int
        for ( int i = 0; i < nums.size(); i++) {
            nums[i] *= nums[i];
        }

        sort(nums.begin(), nums.end()); 
        return nums;
    }
```

方法2：双指针法

- 由于非递归序列有负数，两端的平方大，中间的平方小
- 设置头尾指针，比较其平方
- 大数从后向前插入到新数组中，大数指针向内移动1

```cpp
vector<int> sortedSquares(vector<int>& nums) {
        //思路
        //原数组已有序，由于负数的存在，两端的数平方大，而中间数平方小
        //因此，只需要创建一个空数组，和双指针指向原数组的头尾
        //1.比较两个指针的平方
        
        
        vector<int> ans(nums.size());//构造新数组
        int i = 0; int j = nums.size() - 1;//左右指针
        int k = ans.size() - 1;

        while ( i <= j ) {
            //  1.比较两个指针的平方
            //  2.大数从后往前插入
            //  3.大数的指针向内移动一位
            if ( ( (nums[i] * nums[i]) > (nums[j] * nums[j])) ) {
                ans[k] = nums[i] * nums[i];
                i++;
            }
            else {
                ans[k] = nums[j] * nums[j];
                j--;
            }
        }
        return ans;  
        return ans;
    }
```

## 27 长度最小的子数组

**题目：**

> 给定一个含有 `n` 个正整数的数组和一个正整数`target` 。
>
> 找出该数组中满足其和` ≥ target` 的长度最小的 连续子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回`0` 。
>

**提示：**

> - `1 <= target <= 109`
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 105`

思路：

方法1：暴力解法，用两层循环枚举所有子集，保存最小子集长度

```cpp
 int minSubArrayLen(int t, vector<int>& nums) {
        int i = 0;

        int minSize = INT32_MAX;
        while( i < nums.size()) {
            int ans = 0;
            for ( int j = i; j< nums.size(); j++) {
                ans += nums[j];
                if (ans >= t) {
                    minSize = minSize > (j-i+1) ? (j-i+1) : minSize;
                    break;
                }
            }
 
            i++;
        }
        return minSize < INT32_MAX ? minSize : 0 ;
    }
```

方法2：==滑动窗口法==，用双指针+单层循环进行枚举符合要求的子集，减少了不必要的计算

```cpp
int minSubArrayLen(int t, vector<int>& nums) {
        int i = 0;
        int minSize = INT32_MAX;
        int sum = 0;
        //循环中为终止指针
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while ( sum >= t ) {//只有当窗口内sum满足target时才进行更新起始指针
            //暴力解法相当于每次将起始指针更新到0
            //滑动窗口解法相当于每次将起始指针后移一位,减少了不必要的子集计算
                minSize = min(minSize, (j-i+1));
                sum -= nums[i];
                i++;//更新起始指针
            } 
        }

        return minSize < INT32_MAX ? minSize : 0 ;
    }
```

## 59 螺旋矩阵Ⅱ

**题目：**

> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**提示：**

> - `1 <= n <= 20`

**思路：**

对四个边的边界条件分别处理，采取循环条件一致性，即四个边均为左闭右开

- **边界终点偏移量**需要注意
- **开始的边的起始位置**需要注意
- 循环截至量为循环的圈数，可以用while(loop--)，也可以是for循环
- 对奇数需要对最终的中心值进行赋值

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> a(n ,vector<int>(n));
        int startX = 0; int startY = 0;
        int j = 0; int i = 0;
        int loop = n/2;
        int offset = 1;//循环的边数，或者叫边循环终止偏移量（遵循左闭右开原则）
        int count = 1;//需要填的数
        while( loop-- ) {
            //开始进入每圈填值
            for ( j = startY; j<n-offset; j++) {//处理上边
                a[startX][j] = count++;
            }//此时 i=startX, j=n-offset;
            
            for( i = startX; i < n - offset; i++) {//处理右边
                a[i][j] = count++;
            }//此时 i=n-offset, j=n-offset;

            for( ; j > startY; j--) {//处理下边
                a[i][j] = count++;
            }//此时 i=n-offset, j=startY;

            for( ; i > startX; i--) {//处理左边
                a[i][j] = count++;
            }//此时 i=startX, j=startY;
            
            // printVector(a);
            //准备处理下一圈
            startX++;
            startY++;
            offset++;
            // i++;j++;
        }
        if ( n%2 == 1) {
            a[startX][startY] = count++;
        }

        return a;
    }
};
```





```cpp


class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& mt) {
        
        int m = mt.size();
        int n = mt[0].size();
        if (m==0 || n==0) return {};
        vector<int> a(m*n);
        int count = 0;

        int startX = 0; int startY = 0;
        int i = 0; int j = 0;
        int offset = 1;
        int loop = (min(m, n)) / 2;
        while ( loop-- ) {
            //处理上边
            for ( j = startY; j < n - offset; j++) {
                a[count++] = mt[startX][j];
            }//此时 i=startX, j=n-offset;

            //处理右边
            for ( i = startX; i < m - offset; i++) {
                a[count++] = mt[i][j];
            }// i=m-offset, j=n-offset;

            //处理下边
            for ( ; j > startY; j-- ) {
                a[count++] = mt[i][j];
            }//i=m-offset, j=startY
            
            //处理左边
            for ( ; i > startX; i-- ) {
                a[count++] = mt[i][j];
            }//i=startX, j=startY;

            startX++;
            startY++;
            offset++;
        }
        
        //如果是宽为短边,则需要横着插入最后一行
        if ( min(m, n) % 2 == 1) {
            if( m <= n ){
                for ( int k = startY; k < n - offset+1; k++)
                    a[count++] = mt[startX][k];
            }
            else {
                for ( int k = startX; k < m - offset+1; k++)
                    a[count++] = mt[k][startY];
            }
        }
            


        return a;
    }
};



```

