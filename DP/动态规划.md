# 动态规划 Dynamic Programming DP

## 概述

动态规划五步走：

1. 确定dp数组
2. 确定递归公式
3. dp初始化
4. 确定遍历顺序
5. 举例推导递推公式



## 509 斐波那契数

**题目：**

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```cpp
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

**提示：**
这道题作为DP的入门题，可以更好的让我们理解DP的过程

不过也可以不用DP，递归或者迭代仅保存前后两个结果即可

- 递归
- DP

### 解法一：递归

```cpp
class Solution {
public:
    int fib(int n) {
        if ( n <= 1) return n;

        return fib(n-1) + fib(n-2);
    }
};
```

### 解法二：DP

```cpp
class Solution {
public:
    int fib(int n) {
        if (n < 2) return n;

        int dp[n+1];    // 1.确定dp数组
                        // 2.确定递推公式
        dp[0] = 1;      // 3.dp初始化
        dp[1] = 1;      
                        // 4.dp遍历顺序：前序遍历
        for(int i = 2; i <= n; i++) {
                        // 5.举例推到递推数组
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```



## 70 爬楼梯

**题目：**

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**思路：**
数学归纳法，需要找规律！

- n = 1  ways = 1
- n = 2  ways = 2
- n = 3  ways = 3 = 2 + 1
- n = 4  ways = 5 = 2 + 3
- ......

原理：

- 爬到第n个台阶，只有两种情况能够爬到
  - 在 n-1 个台阶，走一步
  - 在 n-2 个台阶，走两步
  - 故第n阶台阶方法为前两步方法和

### 解法一：DP

- 确定dp数组：`dp[i]` 代表第 `i` 阶楼梯到达的方法数
- 确定递推公式：$dp(i) = dp(i-1) + dp(i+1)$
- 时间复杂度$O(n)$

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if ( n == 1 ) return n;
        int dp[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

### 解法二：数学归纳法

已经发现该题就是斐波那契数列，因此可以直接用斐波那契数列的计算公式

$$F(n) = 1/\sqrt{5} [(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n]$$

- 时间复杂度$O(logn)$

```cpp
class Solution {
    int climbStairs(int n) {
        double sqrt_5 = sqrt(5);
        double fib_n = pow((1 + sqrt_5) / 2, n + 1) - pow((1 - sqrt_5) / 2,n + 1);
        return (int)(fib_n / sqrt_5);
    }
};
```



## 746 使用最小花费爬楼梯

**题目：**

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

**思路：**

该题典型动态规划简单题，需要明确状态转移方程，根据题意可知，到达第i个台阶的花销可以往上爬一级或者两级台阶，因此为了到达第i个台阶，需要取i-1，和i-2的向上爬的最小花销。

- 确定dp数组：dp[i] 代表爬到第 i 个台阶的最小花销
- 确定递推公式：$dp(i) = min(dp(i-1)+cost(i-1)\ ,\  dp(i-2)+cost(i-2))$
- dp初始化：$dp(0)=0\ ,\ dp(1) = 0$

- 确定遍历顺序：前序遍历
- 举例推导dp数组

### 解法：DP

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int p[cost.size()+1];
        p[0] = 0;
        p[1] = 0;
        
        for (int i = 2; i <= cost.size(); i++ ) {
            p[i] = min(p[i-1] +cost[i-1], p[i-2] + cost[i-2]); // 爬到第 i 个台阶需要支付的费用
        }
        return p[cost.size()];

    }
};
```



## 62 不同路径

**题目：**

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

**思路：**

该题有三种思路，由于一个点只有固定路径可以走，因此可以构建树或图来进行，也可以用DP构建状态转移方程

- 深搜
- DP
- 数论，不想看

### 解法一：深搜

将所有路径构建成二叉树，采用深搜的方式对每条路径进行遍历，叶子结点就是终点，计算所有叶子的数量

时间复杂度$O(2^{m+n-1}-1)$

```cpp
class Solution {
private:
    int dfs(int i, int j, int m, int n) {
        if (i > m || j > n) return 0; // 越界了
        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
    }
public:
    int uniquePaths(int m, int n) {
        return dfs(1, 1, m, n);
    }
};
```



### 解法二：DP

动态规划的思路比较容易想一点（个人看法）。

> 什么时候用动态规划？
>
> QA: 可以很快写出状态转移方程时，当前状态由前面状态决定

- 确定dp数组：$dp(n, m)$代表到达$(n, m)$位置有多少条路径

- 确定dp状态转移方程$dp(i, j) = dp(i-1, j) + dp(i, j-1)$
- dp初始化：第一行和第一列都只有一条路就到达
- 确定dp遍历顺序：行遍历 or 列遍历 都可

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // dp(i,j) 代表(i,j)坐标的可能路径数
        // dp(i,j) = dp(i-1, j) + dp(i, j-1)
        
        int dp[m][n] = {0}; // 初始化二维数组
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        } 
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        } 
        for(int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1]; 
    }
};
```



## 63 不同路径II

**题目：**

与 [62：不同路径](https://leetcode.cn/problems/unique-paths/) 题不同的是，整个棋盘上可能会有障碍

**思路：**
大体DP思路与 [62：不同路径](https://leetcode.cn/problems/unique-paths/) 保持一致，只需要对障碍点的dp初始值设为0即可

### 解法: DP

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& ob) {
        // dp(i,j) 代表(i,j)坐标的可能路径数
        // dp(i,j) = dp(i-1, j) + dp(i, j-1)
        int m = ob.size()+1;
        int n = ob[0].size()+1;

        int dp[m][n] = {0}; // 初始化二维数组
        for (int i = 0; i < n+1; i++) {
            dp[0][i] = 0;
        } 
        for (int i = 0; i < m+1; i++) {
            dp[i][0] = 0;
        } 
        dp[1][1]= 1;
        for(int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (i == 1 && j == 1) continue;
                if ( ob[i-1][j-1] == 1) {
                    dp[i][j] = 0;
                }
                else if (ob[i-1][j-1] == 0) {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1]; 
    }
};
```



## 343 整数拆分

**题目：**

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

**提示：**

- `2 <= n <= 58` 

  > n 从2 开始

**思路：**

正整数拆分可以看作为两种情况：

- 两个数  $j \ and \ n-j$

- $j$ 遍历，$n-j$ 重复拆分，和递归一个思路，只不过是迭代完成

当前正整数的拆分的最大乘积就是遍历上面两个情况，由此 *动态规划*  状态转移方程便顺势而出：

$$dp(i)\ = max(\ j \ *(i-j) \ , \ j \ * dp(i-j) \ ) $$

**动态规划五部曲**

- 确定dp数组：$dp(i)$ 代表拆分数字 $i$ 可以获得的最大乘积
- 确定dp状态转移方程：$$dp(i)\ = max(dp(i) \ , \ max(\ j \ *(i-j) \ , \ j \ * dp(i-j) \ )) $$

- 确定遍历顺序：前序遍历
- dp初始化：数字i从2开始，因此 $dp(2) = 1$

- 开始dp

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);

        dp[2] = 1; // dp[i]代表拆分数字i能够得到的最大乘积

        for (int i = 3; i <= n; i++) { 
            // i 代表数字i， 外层循环代表计算2~n的所有乘积
            for(int j = 1; j <= i/2; j++) {
                // 内层循环代表计算当前数字i的所有可能乘积，取最大值
                // j <= i / 2 ，代表在两数相乘时，j x (i-j) = (i-j) x j
                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
};
```



## 96 不同的二叉树

**题目：**

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**提示：**

- `1 <= n <= 19`

**思路：**

需要考虑谁当根节点，以及左右子树的数量，便可以观察状态转移方程

动态规划五步走：

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;
        
        // 外层循环当前总节点数
        for (int i = 1; i <= n; i++ ) {
            // 内层循环j代表根节点值
            // 节点值区间[1, n]
            // 左子树区间[1, j] -> 个数 j-1
            // 右子树区间(j, n] -> 个数 i-j
            for (int j = 1; j <= i; j++) {
                // 不断更新子状态
                dp[i] += dp[j-1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```





## 01 背包问题

### 概述

**问题：** 有一个容量为  $c$ 的背包，和 $n$ 个物品，每个物品具有体积为 $weight(i)$ 和价值为 $value(i)$ ，问这个背包能放下物品的**最大价值和**为多少

 **思路：** 

**回溯三问**

1. 当前操作：

   - 枚举第 $i$ 个物品选与不选：不选，则容量不；选，剩余容量减小 $weight(i)$ 

2. 子问题：

   - 当剩余容量为 $c$ 时，从前 $i$ 个物品中得到的最大价值和

3. 下一个子问题：

   分情况讨论：

   - 不选：从剩余容量为 $c$ 时，从前 $i-1$ 个物品中获得的最大价值和
   - 选：从剩余容量为 $c-wight(i)$ 时，从前 $i-1$ 个物品中获得的最大价值和

递归公式：$dfs(i, c)\  =\  max(dfs(i-1,\  c) \ , \ dfs(i-1,\  c- weight(i))\  +\  value(i))$

**动态规划**

> 动态规划实际上是递推公式，从上到下推出每个子状态，既然能用递归，自然也可以用递推
>
> 注：递推需要保存多个状态栈，**空间复杂度高**
>
> 可以用动态规划吗？
>
> QA：可以。当前状态是由前面子状态获得，因此可以使用dp数组

- dp五步走

  1. 确定dp数组：$dp(i, j)$ 代表当前背包容量为 $j$ 时，从$[0,i]$ 中选取物品可以获得的最大价值和

  2. dp推导公式：$dp(i, j)\  =\  max(dp(i-1,\  j) \ , \ dp(i-1,\  j- weight(i))\  +\  value(i))$

  3. 确定遍历顺序：根据推导公式可以看到，当前状态只与左上角子状态有关，因此先背包后物品 和 先物品后背包都可以

  4. dp初始化：根据dp定义

      $ j<= c \ , \  dp(0, j)$  代表第一个物品能够放入背包，因此dp初始化为 $value(0)$

     $c = 0 \ ,  \ dp(j, 0)$  代表当前容量为0，没有一个物品可以放入，因此dp初始化为 0

  5. 举例递推

  ```cpp
  // 二维dp数组
          // dp[i][j]代表背包容量为j时，从[0,i]取物品获得的最大价值
          vector<vector<int>> dp(weight.size(), vector<int>(c+1, 0));
  
          for (int i = weight[0]; i <= c; i++) {
              dp[0][i] = value[0];
          }
          // 开始放入背包
          for (int i = 1; i < weight.size(); i++) {       // 遍历物品，第一个物品已经初始化
              for (int j = 0; j <= c; j++) {
                  if (weight[i] > j) dp[i][j] = dp[i-1][j];   // 背包容量不够，放不下物品，当前价值不变
                  // 当容量足够时，有两种选择：
                  //  1.不放物品：dp[i-1][j] , 即价值不变
                  //  2.放物品：dp[i-1][j-weight[i]] + value[i]
                  // dp[i][j]代表此时的最大价值，因此在上面两种选择中要取max
                  else {
                      dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
                  }
              } 
          }
  ```

  ```cpp
  // 1维滚动数组
          vector<int> dp(c+1, 0);     //dp(i)代表背包容量为i时候的能存放的最大价值
  		
          for (int i = 0; i < weight.size(); i++) {
              // 未防止计算完前面价值和后会影响后序的dp计算，因此背包遍历需要倒序
              for (int j = c; j >= 0; j--) {
                  if (weight[i] <= j) {
                      dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);
                  }
              }
  
              for (int num :dp) {
                  cout << num << " ";
              }
              cout << endl;
  
          }
          return dp[c];
  ```

  

## 416 分割等和子集

**题目：**

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 **提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

**思路：**

根据题意，实则是找 $target = sum(nums)/2$ 是否能够被数组内元素构成，若要满足要求，$nums$ 必须为偶数

该题可以看作01背包问题，$target$ 实则为背包容量，而 $nums$ 为物品，其值为体积和价值

- 回溯+记忆化搜索（c++，我有点难）
- 二维DP
- 一维滚动数组

### 解法一：回溯+记忆化搜索

>  待解决 python @cache



### 解法二：二维DP

```cpp
/* 二维DP */
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        // target = sum(nums) 
        int sum = 0;
        for (int num: nums) {
            sum += num;
        }

        if (sum % 2 != 0 ) return false;
        sum /= 2; // 当前目标值，即背包容量
        vector<vector<int>> dp(nums.size(), vector<int>(sum+1, 0));

        for (int i = nums[0]; i < sum+1; i++) {
            dp[0][i] = nums[0];
        }

        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j <= sum; j++) {
                if (nums[i] > j) dp[i][j] = dp[i-1][j];
                else {
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - nums[i]] + nums[i]);
                }
            }
        }
        return dp[nums.size()-1][sum] == sum;
    }
};
```

### 解法三：一维滚动数组

```cpp
/* 一维滚动个数组 */
class Solution {
public:
    int dfs(int i, int c, vector<int>& nums) {
        if ( i<0 ) return 0;
       
        if (nums[i] > c)  return dfs(i-1, c, nums);

        return max(dfs(i-1, c, nums), dfs(i-1, c - nums[i], nums) + nums[i]);
    }

    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num: nums) {
            sum += num;
        }
        if (sum % 2 != 0 ) return false;
        sum /= 2; // 当前目标值，即背包容量

        /* 一维滚动数组*/
        sum /= 2; // 当前目标值，即背包容量
        vector<int> dp(sum+1, 0);

        for (int i = 0; i < nums.size(); i++) {
            for (int j = sum; j >= 0; j--) {
                if (nums[i] <= j) {
                    dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
                }
            }
        }
        return dp[sum] == sum;
    }
};
```



## 1049 最后一块石头的重量II

**题目：**

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

**思路：**

该题需要计算的是，所有石头进行相互碰撞，能**剩下的最小重量**是多少？需要思考的是，什么时候相撞剩余重量最小？

- 两两碰撞，其实可以转化为两个子堆进行碰撞，当这两个子堆重量尽可能相同时，剩余重量最小
- 尽可能相同 $==$  $sum(子堆) = sum(stones) / 2$
- 由于代码完成除2操作是向下取整，因此分出的第一堆重量是小于等于  $sum(stones)/2$ 的，而最后剩余重量其实是石子堆总重减去小堆重量的两倍，即 $res = sum(stones) - 2*sum(substones)$

>  该题的难点在于将两个石子相撞，转换成两个子堆相撞

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
       int sum = 0;
       for (int s : stones) {
           sum += s;
       } 
       int c = sum / 2;
       int dp[1502] = {0}; // the capacity of cur stone heap 
	
       for (int i = 0; i < stones.size(); i++) {
           for (int j = c ; j >= stones[i];  j--) {
               dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
           }
       }

       int res = sum - 2 * dp[c];
       return res;
    }
};
```



## 496 目标和

**题目：**

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

**思路：**

题目中描述每个数组都可以为正或负，且其总和为 $target$ ，则意味着数组中有正数和 $p$ 和负数和 $p-sum$

$$p+(p-sum) = target \\ 2p = target+sum \\ p = (target+sum)/2$$

因此，我们实际上要找的就是存在多个正数，其和为 $p$ ，该思想就是01背包问题，即容量为p的背包，正好装满的情况有多少种

**动态规划五步走**

1. dp含义：$dp(i)$ 代表容量为 $i$ 的背包恰好装满的方法有 $dp(i)$ 种
2. dp递推公式：$dp(i) = dp(i) + dp(i-nums(i)$
3. dp初始化：$dp(0) = 1$
4. 确认dp遍历顺序：一维滚动数组，倒序遍历

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {

        for (int num : nums) {
            target += num;
        }
        
        // 2p = (s+t), so (s+t) can't be odd
        // p is the sum of positive nums
        // s is the sum of all nums
        if (target <0 || target % 2) return 0;
        target /= 2;

        // dp[i] means the ways of the sum in all positive nums
        vector<int> dp(target+1, 0);
        
        dp[0] = 1;

        for (int i = 0; i < nums.size(); i++) {
            for (int j = target; j >= nums[i]; j--) {
                dp[j] = dp[j] + dp[j - nums[i]];
            }
        }

        return dp[target];
    }
};
```



## 474 一和零

**题目：**

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`

**思路：**

根据题意有 $m$ 个 0 和 $n$ 个 1 ，因此0和1可以看作是两个背包，或者说一个背包的两个口袋，这两个口袋有各自容量，即二维容量的背包。

> 二维容量的背包含义：无论当前物品有几个0，几个1，此时背包都有 $m*n$ 种状态，因此，需要记录每种状态下背包的最大子集数，即最大价值和

想明白上述二维容量背包，剩下的就是按动规套路进行

**动态规划五部曲**

1. dp含义：$dp(i, j)$ 代表当前背包有 $i$ 个0和 $j$ 个1时，能够存放的最大子集数
2. 确定递推公式：$dp(i, j) = max(dp(i,j), \ dp(i-zoros, \ j-ones) + 1)$， 其中1代表选这个子集，子集数+1
3. dp初始化：$dp(0, 0)=0$ 代表当前背包没有容量的时候不能存放子集，即价值为0
4. dp遍历顺序：二维滚动数组，倒序遍历
5. dp举例递推

### 解法一：二维滚动数组

用二维滚动数组可以优化内存空间，时间复杂度仍为 $O(n*m*n)$

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // dp(i, j) means the max substring number of strs in i ones and j zeros bag
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0)); 

        for (string str : strs) {
            int one = 0; int zero = 0; // weight
            for (char s : str) {
                if (s == '1') one++;
                else if (s == '0') zero++;
            }
            for (int i = m; i >= zero; i--) { // traversal m bag
                for (int j = n; j >= one; j--) {   // traversal n bag
                    dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + 1);
                }
            } 

        }
        return dp[m][n];
    }
};
```

## 322 零钱兑换

**题目：**

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

**思路：**



### 解法一：回溯+记忆化搜索

```cpp
class Solution {
public:
    
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        int cache[n][amount+1];
        memset(cache, -1, sizeof(cache));
        // function函数的用法
        function<int(int, int)> dfs = [&](int i, int c) -> int {
            if (i < 0) {
                return c == 0 ? 0 : INT_MAX / 2; // INT_MAX /2 是防止下面+1溢出
            }
            int &res = cache[i][c]; // 记忆化搜索模板，用地址传递较为方便
            if (res!=-1) return res;
            if (c < coins[i])  return res = dfs(i-1, c);
            return res = min(dfs(i-1, c), dfs(i, c-coins[i]) + 1);
        };
        int ans = dfs(n-1, amount);
        return ans < INT_MAX / 2 ? ans : -1;

    }
};
```



### 解法二：二维dp数组

```cpp
class Solution {
public:
    
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        int dp[n+1][amount+1];
        memset(dp, 0x3f, sizeof(dp)); // 这里为什么用0x3f？
        // 在各项竞赛中，常使用 0x3f3f3f3f 来表示 INF
        // 这是由于 INF + INF < INT32_MAX，不会导致溢出
        // 即当INF 加一个任意正数，不至于溢出
        
        dp[0][0] = 0;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = 0; j <= amount; j++) {
                if (j < coins[i]) dp[i+1][j] = dp[i][j];
                else {
                    dp[i+1][j] = min(dp[i][j], dp[i+1][j-coins[i]] + 1);
                }
            }
        }
        int ans = dp[n][amount];
        return ans < 0x3f3f3f3f ? ans: -1;
    }
};
```

### 解法三：一维滚动数组

```cpp
class Solution {
public:
    
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        int dp[amount+1];
        // 由于我们要求的是最少，因此需要将dp数组初始化为无穷大，从而能够在下面取 minimum
        memset(dp, 0x3f, sizeof(dp)); 
        dp[0] = 0;

        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = min(dp[j], dp[j-coins[i]] + 1);
            }
        }
        int ans = dp[amount];
        return ans < 0x3f3f3f3f ? ans: -1;

    }
};
```



## 518 零钱兑换II

**题目：**

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

**思路：**

### 解法一：递归 + 记忆化搜索

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        int cache[n][amount+1];  
        memset(cache, -1, sizeof(cache));

        function<int(int, int)> dfs = [&] (int i, int c) -> int {
            if (i < 0) return c == 0? 1: 0;
            int& res = cache[i][c];
            if (res != -1) return res;
            if (coins[i] > c) return res = dfs(i-1, c);
            return res = dfs(i-1, c) + dfs(i, c-coins[i]);
        };
        int ans = dfs(n-1, amount);
        return ans;
    }
};
```



### 解法二：二维DP数组

```
不写了
```

### 解法三：一维滚动数组

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;

        for (int i = 0; i < coins.size(); i++) {
            for (int c = coins[i]; c <= amount; c++) {
                // 完全背包 前序遍历
                // 01背包 后序遍历
                dp[c] = dp[c] + dp[c-coins[i]];
            }
        }
        return dp[amount];
    }
};
```



## 377 组合总和

**题目：**

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

**思路：**

根据题意，求的是组成 $target$ 的组合数，即因此在遍历顺序上需要注意。

- 如果是求排列，{1,3} 和 {3,1} 是不同的，需要先遍历背包，再遍历物品
- 如果是求集合，{1,3} 和 {3,1} 是相同的，需要先遍历物品，再遍历背包

### 解法一：一维滚动数组

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        // 一维滚动数组
        int dp[target+1];
        memset(dp, 0, sizeof(dp));
        dp[0] = 1;
        // dp 代表总和为target的元素组合的个数
        for (int i = 0; i < target+1; i++) {
            for (int j = 0; j < nums.size(); j++) {
                if (nums[j] <= i && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    // 首先，元素大小小于剩余目标和
                    dp[i] = dp[i] + dp[i - nums[j]];
                }
            }
        }
        return (int) dp[target];
    }
};
```

### 解法二：递归 + 记忆化搜索

> 需要加强学习，下来重点观察

 

## 139 单词拆分

**题目：**

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅有小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

**思路：**

题目中**查询单词实际上是要将字符串分割成多个子串**，查看子串是否能被字典中的单词组成。

> 分割字符串，如果想不到回溯+dfs 这道题动态规划也够呛，因为**动态规划实际上就是dfs的递推表达式**

- 回溯+dfs + 记忆化搜索
- 动态规划

### 解法一：dfs + 记忆化搜索

> 没看明白 记忆化搜索 在哪里节省时间了

- memory 代表 以当前字符开头的子串，是否被单词组成
- QA：初始化赋值为true， 代表当前子串可以查到，但当从字符串第一个字母开始遍历时，dfs要把后序结果全部遍历一遍，此时会更新memory的状态，当从字符串第二个字母开始遍历时，后序子串已经遍历过了，因此不需要再遍历，从而节省了时间复杂度

```cpp
class Solution {  
private:
    bool backtracking (const string& s,
            const unordered_set<string>& wordSet,
            vector<bool>& memory,
            int startIndex) {
        if (startIndex >= s.size()) {
            return true;
        }
        // 如果memory[startIndex]不是初始值了，直接使用memory[startIndex]的结果
        if (!memory[startIndex]) return memory[startIndex];
        for (int i = startIndex; i < s.size(); i++) {
            string word = s.substr(startIndex, i - startIndex + 1);
            if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet, memory, i + 1)) {
                return true;
            }
        }
        memory[startIndex] = false; // 记录以startIndex开始的子串是不可以被拆分的
        return false;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> memory(s.size(), 1); // -1 表示初始化状态
        return backtracking(s, wordSet, memory, 0);
    }
};
```



### 解法二：dp 滚动数组

动态规划五步走：

1. 确定dp数组：$dp(i)$ 代表分割点为 $i$ ，$i$ 前面的子串是否能由字典中的单词组成

2. dp推导公式：需要找到前缀分割点 $i$ ，和后缀分割点 $j$

   $if \  substr \ in \ wordDict \ and \ prefiex \  is \  true :\\dp(i) = dp(i)$

3. dp遍历顺序：前序遍历

4. dp初始化：空字串默认可以被构成 $dp(0) = true$

5. 开始dp

- 将字符串作为背包，遍历每个分割的字符串
  - 如果前面子串（起始子串：确定已经能够分割）能够由单词拼写的时候，且后面子串（后面分割的子串：剩余子串分割的第一个子串）也能够被单词拼写的时候，当前分割点可以被字典中单词组成，dp状态为true

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        bool dp[n+1];
        memset(dp, false, sizeof(dp));
        dp[0] = true;
         
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j <= n; j++) {
                string str = s.substr(i, j-i);
                if (dp[i] && (find(wordDict.begin(), wordDict.end(), str) != wordDict.end())) {
                    dp[j] = true;
                }
            }
        }
        return dp[n];
    }
};
```



## 189 打家劫舍

**题目：**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

**思路：**

题意说的是邻居不能偷，且要偷的最大金额，其实是有两种可能

- 邻居被偷，我不能偷
- 邻居没被偷，我能够偷，此时要和 $dp(i-1)$ 偷窃金额和 $dp(i-2)+nums[i-1]$ 取最大

重点在dp的定义上

**动规五步走**

1. dp数组：$dp(i)$ 代表到第 $i$ 家是能够偷的最大金额

   此时分两种状况：

   - 跳多个房子再偷，此时 $dp(i)$ 已经记录了多家不偷的时候的最大金额
   - 隔一个偷一个

2. dp推导公式：$dp(i) = max(dp(i-2)+nums(i-1), dp(i-1))$

3. dp遍历顺序：前序遍历

4. dp初始化：都为0，一个都还没偷呢

5. 递推

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        int dp[nums.size()+1];

        memset(dp, 0, sizeof(dp));
        
        dp[0] = 0;
        dp[1] = nums[0];

        for (int i = 2; i <= nums.size(); i++) {
            // 偷不偷，取决于邻居偷没偷
            // 邻居偷了，我就不能偷 dp[i-1]
            // 邻居没偷，我就要偷   dp[i-2] + nums[i-1]
            // 我当前最高的金额就是两个取最大
                dp[i] = max(dp[i-2] + nums[i-1], dp[i-1]); 
        }
        return dp[n];
    }
};
```



## 213 打家劫舍II

**题目：**

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

**思路：**

遇到环可以分情况讨论！！！

遇到环可以分情况讨论！！！

遇到环可以分情况讨论！！！ 

**重要的事情说三遍！**

### 解法一：动态规划

```
class Solution {
public:
    int robrange(vector<int>& nums, int start, int end) {
        // if (start == end) return nums[start]; // 确保至少有两个房子
        int n = nums.size();
        int dp[n];
        memset(dp, 0, sizeof(dp));
        dp[start] = nums[start];
        dp[start+1] = max(nums[start], nums[start+1]);
        for (int i = start+2; i <= end; i++) {
            dp[i] = max(dp[i-2]+ nums[i], dp[i-1]);
        }
        return dp[end];
    }

    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        if (n == 2) return max(nums[0], nums[1]);

        int rob_without_end = robrange(nums, 0, n-2);
        int rob_without_first = robrange(nums, 1, n-1);
        // return rob_without_end;
        return max(rob_without_first, rob_without_end);
    }
};
```



## 337 打家劫舍 III

**题目：**

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 

**提示：**

- 树的节点数在 `[1, 104]` 范围内
- `0 <= Node.val <= 104`

**思路：**

1. 打家劫舍，需要考虑这个节点偷与不偷，由于需要考虑邻居的情况，父节点偷不偷取决于孩子节点，因此需要从下向上偷，*后序遍历*，用递归来写
2. 如果偷，则孩子节点不能偷
3. 如果不偷，孩子节点可以**考虑偷**
4. **综上，孩子节点需要有偷与不偷两种状态，因此需要长度为2的数组来保存孩子状态**

该题有两种种解法：

- 记忆化回溯+dfs
- 动态规划

### 解法一：记忆化回溯+dfs

暴力求解所有可能，这个节点偷与不偷，但root偷的时候可能会计算一遍孙子，root不偷的时候可能也会计算一遍孙子，从而导致重复计算，因此需要记忆化回溯

```cpp
class Solution {
public:
    unordered_map<TreeNode*, int> um;
    int rob(TreeNode* root) {
        if (root == nullptr) return 0;
        if ((root->left == nullptr) && (root->right == nullptr)) return root->val;
        
        if (um[root]) return um[root];
        // 偷父节点
        int res_rob = root->val;
        if (root->left)  res_rob += rob(root->left->left) + rob(root->left->right);// 如果父节点偷，只能偷孙子节点
        if (root->right) res_rob += rob(root->right->left) + rob(root->right->right);

        // 不偷父节点
        int res_no_rob = rob(root->left) + rob(root->right);

        um[root] = max(res_rob, res_no_rob);

        return max(res_rob, res_no_rob);
    }
};
```



### 解法二：动态规划

递归三部曲：

- 递归输入参数：当前节点
- 递归终止条件：当访问到空节点，无法偷，返回{0， 0},
- 后续遍历
- dp递归公式
  - 偷 ：$gold_{rob} = left_{no\_rob}+right_{no\_rob}+gold_{cur}$
  - 不偷：$gold_{no\_rob} = max(left_{rob}, left_{no\_{rob}})+max(right_{rob}, right_{no\_rob})$
- 开始举例递推

```cpp
class Solution {
public:
    vector<int> robTree(TreeNode* cur) {
        if (cur == nullptr) return {0, 0};

        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
		
        // 如果当前节点偷，则孩子均不能偷
        int gold_with_rob = left[1] +  right[1] + cur->val;
        
        // 如果当前节点不偷，则孩子考虑偷，即在孩子偷与不偷之间找个最大值
        int gold_without_rob = max(left[1], left[0]) + max(right[0], right[1]);
        return {gold_with_rob, gold_without_rob}; 
    }

    int rob(TreeNode* root) {
        if (!root) return 0;
        vector<int> dp = robTree(root);
        return max(dp[0], dp[1]);
    }
};
```



## 121 买卖股票的最佳时机

**题目：**

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

**思路：**

根据题意，只能有一次买卖，因此肯定是用**当前最小成本买，最大利润卖**，也就是说，在已扫描的日子，找到最小的成本，保留每次最大利润。

两种解法：

- 贪心（双指针）
- 动态规划

### 解法一：贪心

- 局部最优：当前最小成本下能获得最大利润
- 全局最优，全局最大利润

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = prices[0]; // 当前最小成本初始化
        int n = prices.size();
        int res = 0; // 当前最大利润为0
        for (int i = 1; i < n; i++) {
            res = max(res, prices[i]-low); 	// 每次找局部最优
            low = min(low, prices[i]);		// 更新当前最小成本 
        }
        return res;
    }
};
```



### 解法二：动态规划

根据贪心可以知道，我们要找**两个状态，当前最小成本，当前最大利润**，因此需要二维dp状态

动态规划五部曲：

1. 确定dp数组
   - $dp(i, 0)$ 代表当前最小成本
   - $dp(i, 1)$ 代表当前最高利润
2. dp推导公式：考虑两种状态
   - 当前最小成本：$dp(i, 0) = min(dp[i-1][0], prices(i))$ 
   - 当前最大利润：$dp(i, 1) = max(dp(i,1), prices(i)-dp(i-1, 0))$
3. 确定遍历顺序：前序遍历
4. dp初始化：
   - 当前最小成本是买入股票，不能是0
   - 当前最大成本是0，因为第一天最多不买，但不能卖
5. 举例递推

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][2];
        // dp[i][0] 代表当前持有股票，所剩的钱（或者叫成本）
        // dp[i][1] 代表当前不持有股票，所能赚到的钱
        memset(dp, 0, sizeof(dp));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i++) {
            // 持有当前股票，成本最小化
            dp[i][0] = max(dp[i-1][0], -prices[i]); // 已经持有股票 或者 未持有需要买入

            // 不持有当前股票，利润最大化
            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]);
        }
        return dp[n-1][1];
    }
};
```



## 122 买卖股票的最佳时机 II

**题目：**

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

**思路：**

根据题意：可以发生多次交易，且当天可以买卖，求获得的最大利润，也就是说从第一天开始，只要有利润，我就交易，则最终我获得的利润最大。

两种解法

- 贪心
- 动态规划

### 解法一：贪心

局部最优：相邻两天发生正利润

全局最优：利润最大

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
        int maxP = 0;
        for (int i = 1; i < prices.size(); i++) {
            maxP += max(prices[i] - prices[i-1], 0);
        }
        return maxP;
    }
};
```



### 解法二：动态规划

卖与不卖，每一天发生买卖，两种状态，交易时的利润，不交易时的利润，取最大

动态规划五部曲

1. 确定dp数组：$dp(i)$ 代表到第 $i$ 天获得的最大利润
2. dp推导公式：$dp(i) = max(dp(i-1)，dp(i-1)+prices(i) - prices(i-1))$
3. 确定遍历顺序：前序遍历
4. dp初始化：$dp(0) = 0$ 肯定无法获得利润，自然初始化为0
5. 开始递推

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n];// dp(i) 代表今天可以获得的最大利润
        memset(dp, 0, sizeof(dp));

        for (int i = 1; i < n; i++) {
            dp[i] = max(dp[i-1], dp[i-1] + prices[i] - prices[i-1]);
        }
        return dp[n-1];
    }
};
```



### 解法三：代码随想录

1. 确定dp数组：

   - $dp(i,0)$ 表示第 $i$ 天**持有**股票所得现金。

   - $dp(i,1)$ 表示第 $i$ 天**不持有**股票所得最多现金

2. dp推导公式：

   持有股票：

   - 第 $i-1$ 天持有股票，保持现状，所得现金就是昨天持有股票时的所得现金 $dp(i-1, 0)$
   - 第 $i-1$ 天未持有股票，需要购买，所得现金是之前不持有股票所得现金减去今天花销 $dp(i-1, 1) - prices(i)$

   - $dp(i, 0) = max(dp(i-1, 0), dp(i-1, 1)-prices(i))$

   不持有股票：

   - 第 $i-1$ 天未持有股票，保持现状，所得现金就是昨天未持有股票时的所得现金 $dp(i-1, 1)$
   - 第 $i-1$ 天持有股票，第 $i$ 天卖出股票，所得现金是之前持有股票所得现金加上今天所赚 $dp(i-1, 0) + prices(i)$

   - $dp(i,1) = max(dp(i-1,1), dp(i-1, 0) + prices(i))$

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```



## 123 买卖股票的最佳时机 III

**题目：**

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 105`

**思路：**

只能完成**两笔**交易，每笔交易都有两个状态，持有还没未持有，因此对于每一天都要查询这两笔交集，实际上就是4个状态

- 不做任何状态（只需要初始化）
- 第一次持有	 （买）
- 第一次未持有 （卖）
- 第二次持有     （买）
- 第二次未持有 （卖）
- 注意：还应该添加一个初始状态，不做任何操作，0交易

### 解法一：状态机DP

五部曲：

1. 确定dp数组：
   - $dp(i,0)$：第 $i$ 天不做任何操作
   - $dp(i, 1)$：第 $i$ 天**第一次持有**股票的所得金额
   - $dp(i, 2)$：第 $i$ 天**第一次未持有**股票的所得金额
   - $dp(i, 3)$：第 $i$ 天**第二次持有**股票的所得金额
   - $dp(i, 4)$：第 $i$ 天**第二次未持有**股票的所得金额
2. 确定递推公式：每天各个状态都需要进行一次更新
   - $dp(i, 1) = max(dp(i-1, 1), dp(i-1, 0)-prices(i))$：
   - $dp(i, 2)= max(dp(i-1, 2), dp(i-1, 1)+prices(i))$
   - $dp(i, 3)= max(dp(i-1, 3), dp(i-1, 2)-prices(i))$
   - $dp(i, 4) = max(dp(i-1, 4), dp(i-1, 3)+prices(i))$
   - 总结，当前状态 等于 上个相同状态与上个不同状态的买/卖 取最大
   - 换言之，当前持有，max(上一次已持有， 上一次未持有需买)，当前未持有，max(上一次未持有，上一次已持有需卖)，买意味着花钱，卖意味着赚钱
3. 确定递推顺序：前序遍历，当前状态与上个状态相关
4. dp初始化：没有发生交易，就没有收入，$dp(i, 0 2 4)$ 全为0，持有意味有交易需花钱，$dp(i, 13)$ 全为 $-prices(0)$
5. 开始递推

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int k = 2;

        int dp[n][2*k+1];
        memset(dp, 0, sizeof(dp));

        dp[0][0] = 0;           // 没有任何操作
        dp[0][1] = -prices[0];  // 第一次持有
        dp[0][2] = 0;           // 第一次未持有
        dp[0][3] = -prices[0];  // 第二次持有
        dp[0][4] = 0;           // 第二次未持有

        for (int i = 1; i < n; i++) {
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]); // 前一次持有 , 前一次未持有,需买入
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]); // 前一次未持有, 前一次持有, 需卖出
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]); // 前一次持有 , 前一次未持有,需买入
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]); // 前一次未持有, 前一次持有, 需卖出
        }
        return dp[n-1][2*k];
    }
};
```

观察上述状态可以发现，其实限制 $k$ 次交易，每次交易只有两个状态，因此只需要用遍历状态进行更新即可，

```cpp
int dp[n][2*k +1];

for (int i = 1; i < n; i++ ) {
	for(int j = 1; j <= k) {
		dp[i][2*j-1] = max(dp[i-1][2*j-1], dp[i-1][2*j-2]-prices[i]);
		dp[i][2*j] = max(dp(dp[i-1][2*j], dp[i-1][2*j-1] + prices[i]));
	}
}
```

### 解法二：记忆化搜索

> 待续



## 188 买卖股票的最佳时机 IV

**题目：**

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格，和一个整型 `k` 。	

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**提示：**

- `0 <= k <= 100`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

**思路：**

根据题意，最多可以进行 $k$ 次交易，本质上和 [股票交易 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) 一样，需要考虑每一天每次交易的状态，共 $2k$ 个。

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        int dp[n][2*k+1];
        memset(dp, 0, sizeof(dp));
		// 对持有股票的状态赋初值，即需要买股票
        for (int i = 1; i <= k; i++) {
            dp[0][2*i-1] = -prices[0];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][2*j-1] = max(dp[i-1][2*j-1], dp[i-1][2*j-2] - prices[i]); // 前一次持有 , 前一次未持有,需买入
                dp[i][2*j] = max(dp[i-1][2*j], dp[i-1][2*j-1] + prices[i]); // 前一次未持有, 前一次持有, 需卖出
            }
        }
        return dp[n-1][2*k];
    }
};
```



## [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

**题目：**

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**思路：**

根据题意，卖出股票有冷静期，也就是说是否能买入，与前一天是否卖出（未持有）有关，换句话讲就是考虑前天的未持有状态。

### 解法一：状态机DP

确定推导公式，分两种情况讨论：

1. 当前持有股票， 如果上一天持有股票，保持现状（不买)，其次**如果需要买，那么上一天不持有股票，但是此时需要看前天的状态，只有当前天也未持有股票才能购买**

   $dp(i, 0) = max(dp(i-1, 0) , dp(i-2, 1) - prices(i))$

2. 当前未持有股票，如果上一天未持有股票，则保持现状(不卖)， 其次，如果上一天持有股票，则需要卖

   $dp(i, 1) = max(dp(i-1,1), dp(i-1, 0)+prices(i))$

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int k = 2;

        int dp[n+1][2];
        memset(dp, 0, sizeof(dp));
        dp[1][0] = -prices[0]; // 第 i-1 天 持有股票
        dp[1][1] = 0;

        for (int i = 2; i <= n; i++) {
            // 前一次持有 , 前前一次未持有,才能够买入
            dp[i][0] = max(dp[i-1][0], dp[i-2][1] - prices[i-1]); 
            // 前一次未持有, 前一次持有, 需卖出
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i-1]); 
        }
        return dp[n][1];
    }
};
```



##  714 买卖股票的最佳时机含手续费

**题目：**

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**提示：**

- `1 <= prices.length <= 5 * 104`
- `1 <= prices[i] < 5 * 104`
- `0 <= fee < 5 * 104`

**思路：**

本题不一样之处在于有一个手续费，只有卖出股票时才需要计算，因此只有在未持有状态时才需要减去手续费

1. 当前持有股票， 如果上一天持有股票，保持现状（不买)，其次**如果需要买，那么上一天不持有股票，但是此时需要看前天的状态，只有当前天也未持有股票才能购买**

   $dp(i, 0) = max(dp(i-1, 0) , dp(i-2, 1) - prices(i))$

2. 当前未持有股票，如果上一天未持有股票，则保持现状(不卖)， 其次，如果上一天持有股票，则需要卖，需要付一次手续费

   $dp(i, 1) = max(dp(i-1, 1), dp(i-1, 0) + prices(i) - fee)$

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        int dp[n][2];
        memset(dp, 0, sizeof(dp));
        dp[0][0] = -prices[0];
        
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
        }
        return dp[n-1][1];
    }
};
```



## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

**题目：**

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

> memset c++ 头文件是 `include <cstring>` c 头文件是 `include <string.h>`
>
> `memset(数组名, int val, sizeof(数组名))`
>
> - 如果是 int 数组， int 在 32 位操作系统上是4个字节，0x12345678 代表4个字节内容
>
> - 数组名表示数组的地址
>
> - val 表示每个字节填充的值
>
> - sizeof (数组名)：给数组类型的每个元素每个字节赋值为 val
>
>   **如果是 int_t ， 4个字节，val=1的话，意味每个字节是 `01` 则每个int 元素为 `0x01010101` 十进制就是 `16843009`**
>
> - 综上，==一般用`memset` 给数组初值 `0 or -1`==

**思路：**

重点：下标为 $i$ 的递增子序列长度，与下标为 $j$ 的子序列长度有关，即**需要从头遍历一遍 $0-i$ 元素，统计最大长度**

两种简单思路：

- 选或不选：只与上一个相比，每个 $i$ 需要两个状态

- 枚举选哪个：选择比 $nums(i)$ 小的那个 $j$

  $dfs(i) = max(dfs(i), dfs(j)+1) \ if\  j < i \ \& nums(i) > nums(j)$ 
  

> 拓展，如果是非严格递增子子序列，判断条件改为 $nums(i) >= nums(j)$

### 解法一：动态规划

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();

        int dp[n]; // 第i个元素的最大递增子序列长度
        for (int i = 0; i < n; i++ ) dp[i] = 1;
        int res = 1;
        for (int i = 1; i < n; i++){    
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            res = max(dp[i], res);
        }
        return res;
    }
};
```

### 解法二：记忆化搜索

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int> &nums) {
        int n = nums.size(), memo[n];
        memset(memo, 0, sizeof(memo)); // 本题可以初始化成 0，表示没有计算过
        function<int(int)> dfs = [&](int i) -> int {
            int &res = memo[i];
            if (res) return res;
            for (int j = 0; j < i; ++j)
                if (nums[j] < nums[i])
                    res = max(res, dfs(j));
            return ++res;
        };
        int ans = 0;
        for (int i = 0; i < n; ++i)
            ans = max(ans, dfs(i));
        return ans;
    }
};
```



## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

**题目：**

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1],nums[r]]` 就是连续递增子序列。

**思路：**

根据题意，连续递增，那么只与上一个元素的状态是否递增有关

- 贪心
- 动态规划

### 解法一：贪心

- 局部最优：当前是递增序列的长度
- 全局最优：最大递增序列长度

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int res = 1;
        int count = 1;
        for (int i = 0; i < n-1; i++) {
            if (nums[i+1] > nums[i]) {
            // 是递增序列，长度+1
                count++;
                res = max(res, count); // 取全局最大长度
            }
            else {
                count = 1;
            }
        }
        return res;
    }
};
```



### 解法二：动态规划

1. dp数组：$dp(i)$ 表示 第 $i$ 个元素之前（包含自己）最大递增子序列长度
2. dp递推公式：$dp(i) = dp(i-1)+1  \ \text{if num(i) > nums(i-1)}$
3. 递归顺序：前序遍历
4. dp初始化：$dp(0)= 1$

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int dp[n];
        for (int i=0; i< n; i++) dp[i] = 1;
        int res = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) {
                dp[i] += dp[i-1];
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```



## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

**题目：**

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

**思路：**

根据题意，找的是连续重复子序列，因此当前长度，只与前一个num有关

解法有两种：

- 动态规划
- 滑动窗口

### 解法一：动态规划

二维dp数组，

- 时间复杂度 $O(n^2)$
- 空间复杂度 $O(n^2)$

1. $dp(i, j)$ 代表 $nums1(i-1) 和 nums2(j-1)$ 以前的 $LCS$ 长度
2. $dp(i, j) = dp(i-1, j-1)+1,  \text{ if nums1(i) == nums2(j)}$

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        int dp[n1+1][n2+1];
        memset(dp, 0, sizeof(dp));
        int res = 0;
        for (int i = 1; i<= n1; i++) {
            for(int j = 1; j<=n2; j++) {
                if (nums1[i-1] == nums2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                res = max(dp[i][j], res);
            }
        }
        return res;
    }
};
```

用一维滚动数组优化空间

- 空间复杂度 $O(min(n, m)$ ：可以做到空间只取最小的数组的，需要加个判断

```cpp
class Solution {
public:
    int dfs(int n1, int n2, vector<int>$ nums1, vector<int>& nums2) {
        int dp[n2+1];
        memset(dp, 0, sizeof(dp));
        int res = 0;
        for (int i = 1; i<= n1; i++) {
            for(int j = n2; j> 0; j--) {
                if (nums1[i-1] == nums2[j-1]) {
                    dp[j] = dp[j-1] + 1;
                }
                else {
                    dp[j] = 0;
                }
                res = max(dp[j], res);
            }
        }
        return res;
    }
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        res = (nums1.size() > nums2.size() ? dfs(nums1.size(), nums2.size(), nums1, nums2) \
              : dfs(nums2.size(), nums1.size(), nums2, nums1));
        return res;
    }
};
```



### 解法二：滑动窗口

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20230428160822977.png" alt="image-20230428160822977" style="zoom:50%;" />

找最长相等前缀

```cpp
class Solution {
public:
    int maxLength(vector<int>& A, vector<int>& B, int addA, int addB, int len) {
        int ret = 0, k = 0;
        for (int i = 0; i < len; i++) {
            if (A[addA + i] == B[addB + i]) {
                k++;
            } else {
                k = 0;
            }
            ret = max(ret, k);
        }
        return ret;
    }
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        int ret = 0;
        for (int i = 0; i < n; i++) {
            int len = min(m, n - i);
            int maxlen = maxLength(A, B, i, 0, len);
            ret = max(ret, maxlen);
        }
        for (int i = 0; i < m; i++) {
            int len = min(n, m - i);
            int maxlen = maxLength(A, B, 0, i, len);
            ret = max(ret, maxlen);
        }
        return ret;
    }
};

```



## [1143. 最长公共子序列 ](https://leetcode.cn/problems/longest-common-subsequence/)  and   [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

**思路：**

根据题意，公共子序列可以是不连续的，遍历到 $text1(i) 和 text2(j)$ 时最长 LCS 长度

因此，当前状态和之前的状态相关，想到记忆化回溯和动态规划

- 动态规划
- 记忆化回溯

### 解法一：动态规划

- 确定dp数组：$dp(i,j)$ 代表当前$[0,j-1] \ and [0,i-1]$ 两个子序列的LCS长度
- 当前状态和当前两个子串最后一个元素是否相等相关，因此需要分开判断
  - $dp(i,j) = dp(i-1, j-1)+1 \ \text{if (text1(i) == text2(j))}$
  - $dp(i, j) = max(dp(i-1, j), dp(i, j-1))$

```cpp
class Solution {
public:
    int longestCommonSubsequence(string A, string B) {
        int n1 = A.size();
        int n2 = B.size();
        int dp[n1+1][n2+1];
        memset(dp, 0, sizeof(dp));
        int res = 0;
        for (int i = 1; i<= n1; i++) {
            for(int j = 1; j<=n2; j++) {
                if (A[i-1] == B[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                else {
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
                }
                res = max(dp[i][j], res);
            }
        }
        return res;
    }
};
```

### 解法二：记忆化搜索

```CPP
class Solution {
public:
    int longestCommonSubsequence(string A, string B) {
        int ans = 0;

        int cache[A.size()+1][B.size()+1];
        memset(cache, -1, sizeof(cache)) ;// -1 代表还没有出现
        function<int(int, int)> dfs = [&] (int i, int j) -> int {
            if (i < 0 || j < 0) return 0;
            int &res = cache[i][j];
            if (res != -1) return res;
            
            if (A[i] == B[j]) {
                res = dfs(i-1, j-1)+1;    
            }
            else {
                res = max(dfs(i, j-1), dfs(i-1, j));
            }
            return res;
        };

        return dfs(A.size()-1, B.size()-1);
    }
};
```



## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

**思路：**

两种方式：动态规划 or 贪心

> 贪心在之前有写过，这里先不写了

### 解法一：动态规划

首先据题意可知，**连续和**，那么**第 $i$ 个元素的最大连续子数组**和就需要考虑现在是连续还是不连续

- 连续，前一个元素要选， $dfs(i-1) + nums(i)$
- 不连续：前一个元素不选，$nums(i)$

dp数组：$dp(i)$ 代表 $[0,i]$ 个元素的最大连续和是多少, TIPS：$nums(i)$ 必须要选，如果到这里不连续，那么这个最大连续和就不属于 $dp(i)$

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // 动态规划
        int dp[nums.size()];
        memset(dp, 0, sizeof(dp));
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i-1] + nums[i], nums[i]);
            res = max(dp[i], res);
        }
        return res;


        /* 贪心
        * 核心思想就是要连续和如果为负，那么下个元素不管是正是负都是负优化
        * 连续子数组重新开始选 if (sum < 0) sum = 0; 
        */
        
        // int sum = 0;
        // int maxSum = INT32_MIN; // 假设数组最大和为sum
        // // 求数组总和
        // for (int num : nums) {
        //     sum += num; 
        //     maxSum = max(sum, maxSum);
        //     if (sum < 0) {
        //         sum = 0;
        //     }
        // }
        // return maxSum;
    }
};
```

