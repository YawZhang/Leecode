# 动态规划 Dynamic Programming DP

## 概述

动态规划五步走：

1. 确定dp数组
2. 确定递归公式
3. dp初始化
4. 确定遍历顺序
5. 举例推导递推公式



## 509 斐波那契数

**题目：**

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```cpp
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

**提示：**
这道题作为DP的入门题，可以更好的让我们理解DP的过程

不过也可以不用DP，递归或者迭代仅保存前后两个结果即可

- 递归
- DP

### 解法一：递归

```cpp
class Solution {
public:
    int fib(int n) {
        if ( n <= 1) return n;

        return fib(n-1) + fib(n-2);
    }
};
```

### 解法二：DP

```cpp
class Solution {
public:
    int fib(int n) {
        if (n < 2) return n;

        int dp[n+1];    // 1.确定dp数组
                        // 2.确定递推公式
        dp[0] = 1;      // 3.dp初始化
        dp[1] = 1;      
                        // 4.dp遍历顺序：前序遍历
        for(int i = 2; i <= n; i++) {
                        // 5.举例推到递推数组
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```



## 70 爬楼梯

**题目：**

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**思路：**
数学归纳法，需要找规律！

- n = 1  ways = 1
- n = 2  ways = 2
- n = 3  ways = 3 = 2 + 1
- n = 4  ways = 5 = 2 + 3
- ......

原理：

- 爬到第n个台阶，只有两种情况能够爬到
  - 在 n-1 个台阶，走一步
  - 在 n-2 个台阶，走两步
  - 故第n阶台阶方法为前两步方法和

### 解法一：DP

- 确定dp数组：`dp[i]` 代表第 `i` 阶楼梯到达的方法数
- 确定递推公式：$dp(i) = dp(i-1) + dp(i+1)$
- 时间复杂度$O(n)$

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if ( n == 1 ) return n;
        int dp[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

### 解法二：数学归纳法

已经发现该题就是斐波那契数列，因此可以直接用斐波那契数列的计算公式

$$F(n) = 1/\sqrt{5} [(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n]$$

- 时间复杂度$O(logn)$

```cpp
class Solution {
    int climbStairs(int n) {
        double sqrt_5 = sqrt(5);
        double fib_n = pow((1 + sqrt_5) / 2, n + 1) - pow((1 - sqrt_5) / 2,n + 1);
        return (int)(fib_n / sqrt_5);
    }
};
```



## 746 使用最小花费爬楼梯

**题目：**

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

**思路：**

该题典型动态规划简单题，需要明确状态转移方程，根据题意可知，到达第i个台阶的花销可以往上爬一级或者两级台阶，因此为了到达第i个台阶，需要取i-1，和i-2的向上爬的最小花销。

- 确定dp数组：dp[i] 代表爬到第 i 个台阶的最小花销
- 确定递推公式：$dp(i) = min(dp(i-1)+cost(i-1)\ ,\  dp(i-2)+cost(i-2))$
- dp初始化：$dp(0)=0\ ,\ dp(1) = 0$

- 确定遍历顺序：前序遍历
- 举例推导dp数组

### 解法：DP

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int p[cost.size()+1];
        p[0] = 0;
        p[1] = 0;
        
        for (int i = 2; i <= cost.size(); i++ ) {
            p[i] = min(p[i-1] +cost[i-1], p[i-2] + cost[i-2]); // 爬到第 i 个台阶需要支付的费用
        }
        return p[cost.size()];

    }
};
```



## 62 不同路径

**题目：**

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

**思路：**

该题有三种思路，由于一个点只有固定路径可以走，因此可以构建树或图来进行，也可以用DP构建状态转移方程

- 深搜
- DP
- 数论，不想看

### 解法一：深搜

将所有路径构建成二叉树，采用深搜的方式对每条路径进行遍历，叶子结点就是终点，计算所有叶子的数量

时间复杂度$O(2^{m+n-1}-1)$

```cpp
class Solution {
private:
    int dfs(int i, int j, int m, int n) {
        if (i > m || j > n) return 0; // 越界了
        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
    }
public:
    int uniquePaths(int m, int n) {
        return dfs(1, 1, m, n);
    }
};
```



### 解法二：DP

动态规划的思路比较容易想一点（个人看法）。

> 什么时候用动态规划？
>
> QA: 可以很快写出状态转移方程时，当前状态由前面状态决定

- 确定dp数组：$dp(n, m)$代表到达$(n, m)$位置有多少条路径

- 确定dp状态转移方程$dp(i, j) = dp(i-1, j) + dp(i, j-1)$
- dp初始化：第一行和第一列都只有一条路就到达
- 确定dp遍历顺序：行遍历 or 列遍历 都可

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // dp(i,j) 代表(i,j)坐标的可能路径数
        // dp(i,j) = dp(i-1, j) + dp(i, j-1)
        
        int dp[m][n] = {0}; // 初始化二维数组
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        } 
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        } 
        for(int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1]; 
    }
};
```



## 63 不同路径II

**题目：**

与 [62：不同路径](https://leetcode.cn/problems/unique-paths/) 题不同的是，整个棋盘上可能会有障碍

**思路：**
大体DP思路与 [62：不同路径](https://leetcode.cn/problems/unique-paths/) 保持一致，只需要对障碍点的dp初始值设为0即可

### 解法: DP

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& ob) {
        // dp(i,j) 代表(i,j)坐标的可能路径数
        // dp(i,j) = dp(i-1, j) + dp(i, j-1)
        int m = ob.size()+1;
        int n = ob[0].size()+1;

        int dp[m][n] = {0}; // 初始化二维数组
        for (int i = 0; i < n+1; i++) {
            dp[0][i] = 0;
        } 
        for (int i = 0; i < m+1; i++) {
            dp[i][0] = 0;
        } 
        dp[1][1]= 1;
        for(int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (i == 1 && j == 1) continue;
                if ( ob[i-1][j-1] == 1) {
                    dp[i][j] = 0;
                }
                else if (ob[i-1][j-1] == 0) {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1]; 
    }
};
```



## 343 整数拆分

**题目：**

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

**提示：**

- `2 <= n <= 58` 

  > n 从2 开始

**思路：**

正整数拆分可以看作为两种情况：

- 两个数  $j \ and \ n-j$

- $j$ 遍历，$n-j$ 重复拆分，和递归一个思路，只不过是迭代完成

当前正整数的拆分的最大乘积就是遍历上面两个情况，由此 *动态规划*  状态转移方程便顺势而出：

$$dp(i)\ = max(\ j \ *(i-j) \ , \ j \ * dp(i-j) \ ) $$

**动态规划五部曲**

- 确定dp数组：$dp(i)$ 代表拆分数字 $i$ 可以获得的最大乘积
- 确定dp状态转移方程：$$dp(i)\ = max(dp(i) \ , \ max(\ j \ *(i-j) \ , \ j \ * dp(i-j) \ )) $$

- 确定遍历顺序：前序遍历
- dp初始化：数字i从2开始，因此 $dp(2) = 1$

- 开始dp

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);

        dp[2] = 1; // dp[i]代表拆分数字i能够得到的最大乘积

        for (int i = 3; i <= n; i++) { 
            // i 代表数字i， 外层循环代表计算2~n的所有乘积
            for(int j = 1; j <= i/2; j++) {
                // 内层循环代表计算当前数字i的所有可能乘积，取最大值
                // j <= i / 2 ，代表在两数相乘时，j x (i-j) = (i-j) x j
                dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
};
```

