# 贪心

## 0 概念

**本质：**通过局部最优来推全局最优



## 455 分发饼干

**题目：**

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**思路：**

局部最优：大孩子选择大饼干，心满意足

全局最优，所有孩子都分到饼干，并满足

```
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end()); 	// 孩子排序，从小到大
        sort(s.begin(), s.end());	// 饼干排序，从小到大

        int res = 0;
        int index = s.size() - 1; // 饼干数组的下标
        for (int i = g.size()-1; i >=0; i--) {
        	// 从大孩子开始，且最大饼干可以使大孩子满足时
            if ( (index>=0) && g[i] <= s[index]  ) {
                res++;
                index--;
            }
            // 否则找下一个孩子，即当前的最大饼干一定要满足大孩子才行
        }
        return res;
    }
};
```





## 376 摆动序列

**题目：**

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

==**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得==，剩下的元素保持其原始顺序

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

**思路：**
关键点：什么是子序列

> 题意：子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得
>
> 含义：**子序列可以不连续**（即删除节点），只要存在摆动即可

摆动序列：前后元素差符号相反，即**一个单调增一个单调减**

- 记录前一个变化趋势

  - 0 :  初始化
  - 1 ：上升
  - -1：下降

- 当前后变化趋势相异时，子序列长度+1

  > 初始化子序列长度为1，因此第一个元素无法判断变化趋势，而使得长度少1



### 代码随想录

>  用前后变化值的大小来判断前后变化趋势是否相异

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff 
            }
        }
        return result;
    }
};
```

### 题解

自己设置变化趋势值，当前后变化趋势改变时，更新该值

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() == 1) return nums.size();
        int maxSubNum = 1;
        // 当前序列趋势 0:初始化 1:上升 -1:下降
        int trend = 0; //
        for (int i = 1; i < nums.size(); i++ ) {
            if (nums[i] > nums[i-1] && trend != 1) {
                // 序列上升，但前面序列不上升
                trend = 1;
                maxSubNum++;
            }
            else if (nums[i] < nums[i-1] && trend != -1 ) {
                // 当前序列下降，但前面序列不下降
                trend = -1;
                maxSubNum++;
            }
        }
        return maxSubNum;
    }
};
```

## 53 最大子数组和

**题目：**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

**思路：**

- 暴力解法：双循环找所有子数组和，大概率超时
- 贪心找局部和全局最优

### 解法一：暴力

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) { // 设置起始位置
            count = 0;
            for (int j = i; j < nums.size(); j++) { // 每次从起始位置i开始遍历寻找最大值
                count += nums[j];
                result = count > result ? count : result;
            }
        }
        return result;
    }
};
```



### 解法2：贪心

1. 首先子序列和为负时，说明当前子序列负优化了，则从下一个元素开始计算子序列和，因此负“连续和”加下一个元素连续和只会原来越小

2. 其次，每次记录局部最优，即当局部最优大于全局最优，更新全局最优

   > 如果当前负"连续和"出现，则前面子序列连续和结果已保存，所以不用回头再找

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int maxSum = INT32_MIN; // 假设数组最大和为sum
        // 求数组总和
        for (int num : nums) {
            sum += num; 
            maxSum = max(sum, maxSum);
            if (sum < 0) {
                sum = 0;
            }
        }
        return maxSum;
    }
};
```



## 122 买卖股票的最佳时机II

**题目：**

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**提示:**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

**思路：**
==好好审题！！！==

- 最大利润 = 所有**正利润**之和
- 只要两天买卖有利润，当赚即赚

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
        int maxP = 0; // 最大利润
        if (prices.size() == 1) return maxP;

        for (int i = 1; i < prices.size(); i++) {
        	// 有利可图 -> 当赚即赚
            maxP += max(prices[i] - prices[i-1], 0);
        }
        return maxP;
    }
};
```





## 55 跳跃游戏

**题目：**

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**提示：**

- `1 <= nums.length <= 3 * 104`
- `0 <= nums[i] <= 105`

**思路：**

- 解法一：统计能跳的最远位置，如果最远位置是数组末尾，即true
- 解法二：逐元素跳，如果不能到达末尾位置，返回false
- 解法三：统计剩余能跳的长度，当不能跳是还未到末尾，即返回false

> 解法一和解法二的区别在判断了能到达最远位置，是否提前终止
>
> 解法一：如果能够到达，终止返回，相当于剪枝（统计**可跳最远位置**）
>
> 解法二：如果不能到达，提前返回，如果能到达，全部遍历（统计**可跳最远位置**）
>
> 解法三：如果不能到达，提前返回，如果能到达，全部遍历（统计**剩余可跳长度**）

### 解法一：统计能跳远的长度，如果足够跳到末尾即返回

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
```



### 解法二：统计可跳跃的最远位置，逐元素跳到末尾

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int k = 0; // 当前能跳到的位置
        for (int i = 0; i < nums.size(); i++) {
            if (i > k) return false; // 如果该位置不能跳到，return false
            k = max(k, i + nums[i]); // 如果能跳到，更新目前能跳到的最大位置
        }
        return true;
    }
};
```



### 解法三：统计剩余能跳跃长度

```cpp

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int count = 0; // 统计能够跳跃的长度 当count==nums.size() return true;

        for (int i = 0; i<nums.size(); i++) {
			count = max(nums[i], 0); // 当前剩余能跳位置
            if (count == 0 && i!=nums.size() -1) { // 不能跳了，但还未到末尾
                return false;
            }
        }
        return true;
    }
};
```

