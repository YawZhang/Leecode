# 贪心

## 0 概念

**本质：**通过局部最优来推全局最优



## 455 分发饼干

**题目：**

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**思路：**

局部最优：大孩子选择大饼干，心满意足

全局最优，所有孩子都分到饼干，并满足

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end()); 	// 孩子排序，从小到大
        sort(s.begin(), s.end());	// 饼干排序，从小到大

        int res = 0;
        int index = s.size() - 1; // 饼干数组的下标
        for (int i = g.size()-1; i >=0; i--) {
        	// 从大孩子开始，且最大饼干可以使大孩子满足时
            if ( (index>=0) && g[i] <= s[index]  ) {
                res++;
                index--;
            }
            // 否则找下一个孩子，即当前的最大饼干一定要满足大孩子才行
        }
        return res;
    }
};
```





## 376 摆动序列

**题目：**

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

==**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得==，剩下的元素保持其原始顺序

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

**思路：**
关键点：什么是子序列

> 题意：子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得
>
> 含义：**子序列可以不连续**（即删除节点），只要存在摆动即可

摆动序列：前后元素差符号相反，即**一个单调增一个单调减**

- 记录前一个变化趋势

  - 0 :  初始化
  - 1 ：上升
  - -1：下降

- 当前后变化趋势相异时，子序列长度+1

  > 初始化子序列长度为1，因此第一个元素无法判断变化趋势，而使得长度少1



### 代码随想录

>  用前后变化值的大小来判断前后变化趋势是否相异

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff 
            }
        }
        return result;
    }
};
```

### 题解

自己设置变化趋势值，当前后变化趋势改变时，更新该值

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() == 1) return nums.size();
        int maxSubNum = 1;
        // 当前序列趋势 0:初始化 1:上升 -1:下降
        int trend = 0; //
        for (int i = 1; i < nums.size(); i++ ) {
            if (nums[i] > nums[i-1] && trend != 1) {
                // 序列上升，但前面序列不上升
                trend = 1;
                maxSubNum++;
            }
            else if (nums[i] < nums[i-1] && trend != -1 ) {
                // 当前序列下降，但前面序列不下降
                trend = -1;
                maxSubNum++;
            }
        }
        return maxSubNum;
    }
};
```

## 53 最大子数组和

**题目：**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。	

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

**思路：**

- 暴力解法：双循环找所有子数组和，大概率超时
- 贪心找局部和全局最优

### 解法一：暴力

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) { // 设置起始位置
            count = 0;
            for (int j = i; j < nums.size(); j++) { // 每次从起始位置i开始遍历寻找最大值
                count += nums[j];
                result = count > result ? count : result;
            }
        }
        return result;
    }
};
```



### 解法2：贪心

1. 首先子序列和为负时，说明当前子序列负优化了，则从下一个元素开始计算子序列和，因此负“连续和”加下一个元素连续和只会原来越小

   > 注：负+正 < 正   负 + 负c < 负c ， 因此当子序列和为负，无论后续何值都是负优化

2. 其次，每次记录局部最优，即当局部最优大于全局最优，更新全局最优

   > 如果当前负"连续和"出现，则前面子序列连续和结果已保存，所以不用回头再找

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int maxSum = INT32_MIN; // 假设数组最大和为sum
        // 求数组总和
        for (int num : nums) {
            sum += num; 
            maxSum = max(sum, maxSum);
            if (sum < 0) {
                sum = 0;
            }
        }
        return maxSum;
    }
};
```



## 122 买卖股票的最佳时机II

**题目：**

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**提示:**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

**思路：**
==好好审题！！！==

- 最大利润 = 所有**正利润**之和
- 只要两天买卖有利润，当赚即赚
- 局部最优：正利润
- 全局最优：有利可图，利润最大化

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        
        int maxP = 0; // 最大利润
        if (prices.size() == 1) return maxP;

        for (int i = 1; i < prices.size(); i++) {
        	// 有利可图 -> 当赚即赚
            maxP += max(prices[i] - prices[i-1], 0);
        }
        return maxP;
    }
};
```





## 55 跳跃游戏

**题目：**

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**提示：**

- `1 <= nums.length <= 3 * 104`
- `0 <= nums[i] <= 105`

**思路：**

- 解法一：统计能跳的最远位置，如果最远位置是数组末尾，即true
- 解法二：逐元素跳，如果不能到达末尾位置，返回false
- 解法三：统计剩余能跳的长度，当不能跳是还未到末尾，即返回false

> 解法一和解法二的区别在判断了能到达最远位置，是否提前终止
>
> 解法一：如果能够到达，终止返回，相当于剪枝（统计**可跳最远位置**）
>
> 解法二：如果不能到达，提前返回，如果能到达，全部遍历（统计**可跳最远位置**）
>
> 解法三：如果不能到达，提前返回，如果能到达，全部遍历（统计**剩余可跳长度**）

### 解法一：统计能跳远的长度，如果足够跳到末尾即返回

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        // if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
```



### 解法二：统计可跳跃的最远位置，逐元素跳到末尾

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int k = 0; // 当前能跳到的位置
        for (int i = 0; i < nums.size(); i++) {
            if (i > k) return false; // 如果该位置不能跳到，return false
            k = max(k, i + nums[i]); // 如果能跳到，更新目前能跳到的最大位置
        }
        return true;
    }
};
```



### 解法三：统计剩余能跳跃长度 (*笨办法*)

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int count = 0; // 统计能够跳跃的长度 当count==nums.size() return true;

        for (int i = 0; i<nums.size(); i++) {
			count = max(nums[i], 0); // 当前剩余能跳位置
            if (count == 0 && i!=nums.size() -1) { // 不能跳了，但还未到末尾
                return false;
            }
        }
        return true;
    }
};
```



## 45 跳跃游戏 II 

**题目：**

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。**生成的测试用例可以到达 `nums[n - 1]`。**

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- ==题目保证可以到达 `nums[n-1]`==



**思路：**

1. 统计当前步能到达的最远距离 `stepEnd` ，当 `i` 到最远距离的时候，代表要进行一次跳跃
2. 统计每一步最大能到的最远距离
   - 只有到当前步到达 `stepEnd` 的时候，才更新下一步的 `stepEnd`
3. 遍历每一步，直到 `nums.size() - 2`，因为达到最后一个位置不需要再跳一步

```cpp
// 版本二
class Solution {
public:
    int jump(vector<int>& nums) {
        int res = 0; 
        int maxD = 0;
        int end = 0; 
        for (int i = 0; i < nums.size()-1; i++) {
            maxD = max(maxD, i + nums[i]);
            if (i == end) {
                end = maxD;
                res++;
            }
        }
        return res;
    }
};
```



## 1005 K次取反后最大化的数组和

**题目：**
给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

 **提示：**

- `1 <= nums.length <= 104`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 104`

**思路：**

确认贪心的思考方式

- 可能的最大和（全局最优）
- 负数全变成正数，或者正数最小数翻转才能使和变大（局部最优）

上述过程其实是两次贪心

第一次贪心

- 局部最优：负数全变成整数
- 全局最优：数组和最大

第二次贪心

- 局部最优：全为正，但K不为0， 多次翻转最小正数
- 全局最优：数组和最大

```cpp
class Solution {
    
static bool cmp (int a , int b) {
    return abs(a) > abs(b);
}
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort( nums.begin(), nums.end(), cmp); // 按绝对值从大到小排序
        int res = 0;
        for (int i = 0; i < nums.size(); i++ ) {

            if (nums[i] < 0 && k > 0) {
                // 负数先变为整数
                nums[i] *= -1;
                k--;
            }
        }
        if (k % 2 == 1) {
                nums[nums.size()-1] *= -1; // 如果剩余K是奇数，说明需要翻转最后的最小数，才能使和最大
            }
        for (int num: nums) res+=num;
        return res;
    }
};
```





## 134 加油站

**题目：**

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

**提示：**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`
- $10^4$因此暴力一定超时

**思路：**

- 首先每个加油站剩余油量和非负，则一定能够跑完一圈

- 从 `0-i` 的加油站，如果剩余油量和为负数，则说明 `0-i` 的所有加油站都不可作为起点

  > 解释：因为从0开始，所有相当于 i 之前的所有和为负，以此为条件可以保证 i 前面所有可能和都不满足要求，即最后第 i 个加油站负数最大，因此需从第 i+1 个加油站开始

- 局部最优：当前累加剩余油量非负

- 全局最优：完成一圈后剩余油量非负

### 贪心

- 遍历加油站，计算当前剩余油量
- 若当前剩余油料为负，更新开始起点 (i+1) 
- 如果一圈结束，剩余油量为负，则无论从哪一个加油站为起点，都无法走完一圈，反之，可以
- 时间复杂度 $O(n)$, 空间复杂度$O(1)$

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```





## 135 分发糖果

**题目：**

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`

**思路：**

这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，**如果两边一起考虑一定会顾此失彼**。

- 先从前向后遍历，**若当前孩子比左边孩子大**，给当前孩子分多一个糖果
- 再从后向前遍历，比较当前孩子和右边孩子大小，如果当前孩子大，则需要多分一个糖果
  - 因为已经有了与左孩子的比较，因此需要考虑当前的糖果数
  - 如果当前孩子比右孩子大，如果当前孩子的糖果已满足多分，则不变，如果不满足，则变为右孩子糖果数+1

```cpp
class Solution {
public:
	int candy(vector<int> & r ) {
		vector<int> s(r.size(), 1);//给每个孩子先分一个糖果，保底
		// 前序遍历，确定当前孩子 > 左孩子评分，则多分一个糖果
		for (int i = 1; i < r.size(); i++) {
			if (r[i] > r[i-1]) {
				s[i] = s[i-1] + 1;
			}
		}
		
		// 后序遍历，确定当前孩子 > 右孩子评分，则多分一个糖果
		for (int i = r.size() -2; i >= 0; i--) {
			if (r[i] > cri+1]) {
				s[i] = max(s[i], s[i+1] + 1);
			}
		}
		int res = 0;
		for(int num : s) {
			res += num;
		}
		return res;
	}
}
```



## 860 柠檬水找零

**题目：**

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。



**提示：**

- `1 <= bills.length <= 105`
- `bills[i]` 不是 `5` 就是 `10` 或是 `20` 

**思路：**
遇到没有思路的题目，可以先把==*所有能遇到的情况都分析一遍*==

- 本题只需要维护三个指针，对应三张钞票剩余数量
- 当找零大于5，优先找10块的，再找5块的

### 解法：贪心

- 局部最优：优先消耗 10  ,  5 万能
- 全局最优：完成账单找零

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0, twenty = 0;
        for (int bill : bills) {
            if (bill == 5) five++;
            else if (bill == 10) ten++;

            int res = bill - 5;
            // 优先找10
            if (res > 5) {
                if (ten != 0) {
                    ten--;
                    res -= 10;
                }
            }
            
            // 其次找5
            while(res > 0) {
                if (five == 0) return false;
                five--;
                res -= 5;
            }
        }
        return true;
    }
};
```





## 406 根据身高重建队列

**题目：**

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**提示：**

- `1 <= people.length <= 2000`
- `0 <= hi <= 106`
- `0 <= ki < people.length`
- 题目数据确保队列可以被重建



**思路：**
该题与分发糖果套路类似： **一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。**

- 首先需要对原数对进行排序，按身高大小降序排序，再按照高于自身人数升序排序
- 此时，每个元素的一定满足要求
- 接着重新插入数对中
  - 如果当前元素第二个属性作为插入位置，小于队列长度，则插入相应位置
  - 否则，直接插入队尾

### 版本1：vector

时间复杂度：
空间复杂度：

```cpp
class Solution {
public:
    static bool cmp(vector<int> a, vector<int> b) {
        if (a[0] == b[0]){
            // 如果身高相同，k小的排前面
            return a[1] < b[1];
        }

        return a[0] > b[0];
    }

    vector<vector<int>> reconstructQueue(vector<vector<int>>& p) {
        sort(p.begin(), p.end(), cmp); // 按身高大小排序
        // 此时保证该元素身高都不大于前面元素身高，进而可以按属性进行插入
        vector<vector<int>> que;

        for(vector<int> pp : p) {
            int position = pp[1];

            // 如果当前大于元素的个数<队列的元素, 则需要插入到队列相应位置
            if (position < que.size()) que.insert(que.begin() + position, pp);

            // 如果当前大于元素的个数>=队列的元素, 则直接放到队尾
            else que.push_back(pp);
            
        }
        return que;
    }
};
```

### 版本2：List

由于vector需要进行扩充并插入，时间复杂度实际上是$O({n^2}+t*n)$， t代表扩容次数

```cpp
// 版本二
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};
```



## 435 无重叠区间

**题目：**
给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**提示：**

- `1 <= intervals.length <= 105`

- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 104`



**思路：**

将求**无重叠区间**比作==**预定会议**==十分恰当！！

给你若干时间的会议，然后去预定会议，那么能够预定的最大的会议数量是多少？核心在于我们要找到最大不重叠区间的个数。

- 按照**右端排序**，一定能找到一个最先结束的会议，而这个会议就是我们需要添加到最终结果的首个会议，即**可以预定的会议数**
- 按照**左端排序**，则需要我们每次记录最小的结束会议时间，从而**统计不能预定的会议数**

### 解法一：右端排序

```cpp
class Solution {
public:
	static bool cmp(vector<int>& a, vector<int>& b) 	{
        return a[1] < b[1];
    }
	int eraseOverlapIntervals(vector<vector<int>>& ints) {
        sort(ints.begin(), ints.end(), cmp);//按右端排序

        int count = 1;//可预定的会议数
        int end = ints[0][1];// 会议结束时间

        for(int i = 0; i < ints.size(); i++) {
            if (end <= ints[i][0]) {
                count++;
                end = ints[i][1];
            }
        }
        return ints.size() - count;
	}
};
```

### 解法二：左端排序

- 左端排序与右端排序的区别是，需要统计的是不可预定的会议

```cpp
class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {
        //按x_start升序排序
        return a[0] < b[0];
    }

    int eraseOverlapIntervals(vector<vector<int>>& ints) {
        sort( ints.begin(), ints.end(), cmp );// 按开始区间升序排列

        int res = 0;
        int end = ints[0][1];     // 交集结束
        for(int i = 1; i < ints.size(); i++) {
            if (ints[i][0] < end) {
                // 如果有交集
                res++;//删除该集合
                end = min(ints[i][1], end);
                continue;
            }
            // 否则
            end = ints[i][1];
        }
        return res;
    }
};
```



## 763 划分字母区间

**题目：**

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成  -> 可以用vector做hash

**思路：**

重点在于出现个字符能够达到的**最远距离**

- 如果遍历到已出现字符的最远距离，说明该字符出现的区间为区间内所有字符的并集，即到达前面出现过所有字母的最远距离

### 解法一：找已出现字符的并集

- map统计所有字符出现的区间，并按**开始区间升序排列**
- 遍历map中字符，找每个字符的所有并集的数量

```cpp
class Solution {
public:
    static bool cmp(pair<char, pair<int, int>>& a, pair<char, pair<int, int>>& b) {
        return a.second.first < b.second.first;
    }

    vector<int> partitionLabels(string s) {
        map<char, pair<int, int>>  um;
        
        for(int i = 0; i < s.size(); i++) {
            if (um.find(s[i]) == um.end()) {
                // 没找到
                um[s[i]].first = i;   // 开始区间存入
                um[s[i]].second = i;  // 结束区间存入
            }
            else {
                um[s[i]].second = i; // 更新结束区间
            }
        }
        vector<pair<char, pair<int, int>>> vec(um.begin(), um.end());
        sort(vec.begin(), vec.end(), cmp);
        vector<pair<char, pair<int, int>>>::iterator it = vec.begin();
        int start = it->second.first;  // 开始区间
        int end = it->second.second;   // 结束区间
        it++;
        vector<int> ans;
        for (; it!=vec.end(); it++) {
            if (end > it->second.first){
                // 如果有交集
                end = max(it->second.second, end);// 取并集结束区间
            }
            else {
                // 无交集
                ans.push_back(end - start + 1);
                
                start = it->second.first;  // 开始区间
                end = it->second.second;
            }
        }
        ans.push_back(end - start + 1);
        return ans;
    }
};
```



### 解法二：统计每个字出现的最远距离

- 实时更新当前出现过字符的最远距离
- 当到达最远距离时，代表到达前面出现过所有字母的最远距离
- 此时分割字符串

```cpp
class Solution {
public:
    vector<int> partitionLabels(string S) {
        int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置
        for (int i = 0; i < S.size(); i++) { // 统计每一个字符最后出现的位置
            hash[S[i] - 'a'] = i;
        }
        vector<int> result;
        
        int start = 0;
        int end = 0;
        vector<int> res;

        for (int i = 0; i < S.size(); i++) {
            end = max(end, hash[S[i] - 'a']);
            if (end == i) {
                res.push_back(end- start + 1);
                start = i+1;
            }
        }
        return res;
    }
};
```



## 738 单调递增的数字

**题目：**

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

**提示：**

- `0 <= n <= 109`    ==暴力必超时==

**思路：**

首先要求整数每位数字非递减，其次，保证最后返回的值最大，典型的贪心算法

- 局部最优：如果出现逆序，前一位减一，后一位变为9
- 全局最优：保证高位尽可能不变，从第一个需要借位处开始，后面所有数字变为9

### 解法一：暴力遍历

逐个判断从大到小的数是否符合非递减要求，满足即退出

时间复杂度：$O(n*m)$ , m为需要查找的数组大小

空间复杂度：$O(1)$

```cpp
class Solution {
private:
    // 判断一个数字的各位上是否是递增
    bool checkNum(int num) {
        int max = 10;
        while (num) {
            int t = num % 10;
            if (max >= t) max = t;
            else return false;
            num = num / 10;
        }
        return true;
    }
public:
    int monotoneIncreasingDigits(int N) {
        for (int i = N; i > 0; i--) { // 从大到小遍历
            if (checkNum(i)) return i;
        }
        return 0;
    }
};
```



### 解法二：贪心

- 后序遍历，查找需要第一个需要借位的位置
- 前序遍历，将数字从借位到最后全部赋值 9 ，即最大值

时间复杂度：$O(n)$
空间复杂度：$O(n)$

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string nums = to_string(n);
        int flag = nums.size(); // 初始化借位位置
        // 后序遍历，查找第一个借位位置
        for (int i = nums.size() -1; i > 0; i--) {
            if (nums[i-1] > nums[i]) {
                flag = i;
                nums[i-1]--;
            }
        }
        // 前序遍历，将借位处全变为9
        for (int i = flag; i < nums.size(); i++) {
            nums[i] = '9';
        }
        return stoi(nums);
    }
};
```



## 968 监控二叉树

**题目：**

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

**提示：**

1. 给定树的节点数的范围是 `[1, 1000]`。
2. 每个节点的值都是 0。

**思路：**

首先，考虑什么情况下需要放摄像头覆盖更多的节点，使得摄像头个数最少？典型贪心问题：

- 局部最优：一个摄像头监控更多的节点
- 全局最优：摄像头最少能够将全部节点监控

要想获得局部最优，则需要让摄像头放在父节点，最大化监控范围，换句话说，放在叶子节点的父节点位置，此时，需要考虑两个问题：

1. 二叉树遍历顺序
2. 每个节点监控状态

1.二叉树遍历顺序

根据上面分析，首先要找叶子节点，再找父节点，则需要 **后序遍历** **—— 左右中**

2.每个节点监控状态

一个节点，有什么监控状态？

- 没被监视 —— 0
- 有摄像头 —— 1
- 被监视     —— 2

因此左右孩子节点分一下三个情况：

1. 左右孩子至少有一个没被监控到

   - left = 0 && right == 1
   - left = 0 && right == 2
   - left = 1 && right == 0
   - left = 2 && right == 0

   统一用 `left == 0|| right == 0` 判断，此时**无论左右孩子是否有摄像头，只要有没被监控的孩子，其父节点就需要放置摄像头**， **此时父节点处于*装摄像头*状态**

2. 左右孩子至少有一个有摄像头 （此时左右孩子已判断过没被监控的情况）

   - left = 1 && right == 1
   - left = 1 && right == 2
   - left = 2 && right == 1

   统一用 `left == 1 || right == 1` 判断， 此时**父节点处于*被监控*状态**

3. 左右孩子仅被监控

   情况 3 代表当前节点可以视为叶子节点，**处于*未被监控*状态**

### 解法：贪心

```cpp
class Solution {
public:
    int res = 0;
    int dfs(TreeNode* cur) {
        if (cur == nullptr) return 2;//空节点作为已覆盖情况

        int left = dfs(cur->left); 
        int right = dfs(cur->right);

        // 中
        // 情况1：如果有节点没覆盖，父节点就要装摄像头
        if (left == 0 || right == 0) {
            res++;
            return 1;
        }
        // 情况2：如果有节点已有摄像头，父节点便已覆盖
        else if (left == 1 || right == 1) {
            return 2;
        }
        // 情况3：如果左右节点均已覆盖，则当前节点作为叶子节点，不覆盖
        return 0;
    }
    int minCameraCover(TreeNode* root) {
        if (dfs(root) == 0) res++;
        return res;
    }
};
```

